/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*-*/
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this file,
 * You can obtain one at http://mozilla.org/MPL/2.0/. */

#ifndef ISOCOMPOSITOR_H_
#define ISOCOMPOSITOR_H_

#include "mozilla/Endian.h"
#include "TrackMetadataBase.h"
#include "nsTArray.h"
#include "ISOTrackMetadata.h"
#include "EncodedFrameContainer.h"

namespace mozilla {

class ISOCompositor;

/**
 * This class collects elementary stream data to form a fragmentation.
 * ISOMediaWriter will check if the data is enough; if yes, the corresponding
 * moof will be created and write to ISOCompositor.
 * Each audio and video has its own fragmentation and only one duraing the whole
 * life cycle, when a fragmentation is formed in ISOCompositor, Flush() needs to
 * be called to reset it.
 */
class Fragmentation {
public:
  // aTrackType: it could be Audio_Track or Video_Track.
  // aFragDuration: it is the fragmentation duration, it needs to be the same
  //                value for both.
  Fragmentation(uint32_t aTrackType, uint32_t aFragDuration,
                TrackMetadataBase* aMetadata);

  // Frame will be added/accessed by following functions.
  nsresult GetFrame(uint32_t aIdx, EncodedFrame** aFrame);
  nsresult AddFrame(EncodedFrame* aFrame);
  uint32_t GetCurrentAvailableSampleNumber();

  // Check if it accumulates enough frame data.
  // It returns true when data is enough to form a fragmentation.
  bool HasEnoughData();

  // Flush() will be called when a fragment is written out to a blob.
  // It will clear all of the data in array mFrames.
  nsresult Flush();

  // Called by ISOMediaWriter when TrackEncoder has sent the last frame. The
  // remains frame data will form the last moof and move the state machine to
  // in ISOMediaWriter to last phrase.
  nsresult SetEndOfStream() {
    mEOS = true;
    return  NS_OK;
  }
  bool EOS() { return mEOS; }

  // CSD (codec specific data), it is generated by encoder and the data is
  // depedes on codec type. This data will be sent as a special frame from
  // encoder to ISOMediaWriter and pass to this class via AddFrame().
  nsresult GetCSD(nsTArray<uint8_t>& aCSD);

  uint32_t GetType() { return mTrackType; }

private:
  uint32_t GetSampleNumberPerFragment();

private:
  uint32_t mTrackType;

  // fragmentation duration, it counts by seconds.
  uint32_t mFragDuration;

  // Sample number per fragmentation.
  uint32_t mSamplePerFragment;

  nsTArray<nsRefPtr<EncodedFrame> > mFrames;

  // Codec specific data frame, it will be generated by encoder and send to
  // ISOMediaWriter through WriteEncodedTrack(). The data will be vary dependes
  // on codec type.
  nsRefPtr<EncodedFrame> mCSDFrame;

  // END_OF_STREAM from ContainerWriter
  bool mEOS;
};

/**
 * ISOCOmpositor will be carried to each box when box is created. It is the main
 * bridge for box to output stream to ContainerWritr and retrieve information.
 * ISOCompositor acts 3 different roles:
 * 1. holds the pointer of audio metadata, video metadata, fragmentation and
 *    pass them to boxes.
 * 2. provide the functions to generate the base structure of MP4; they are
 *    GenerateFtyp, GenerateMoov, GenerateMoof, and GenerateMfra.
 * 3. the actually writer used by MuxOperation::Write() in each box. It provides
 *    writing methods for different kind of data; they are Write, WriteInt8~64,
 *    WriteBits.
 */
class ISOCompositor {

friend class BoxSizeChecker;

public:
  ISOCompositor();

  nsresult GenerateFtyp();
  nsresult GenerateMoov();
  nsresult GenerateMoof(uint32_t aTrackType);
  // TODO: mp4 mfra box is for random access. Some player doesn't need this box
  // for random seeking; for example, Google Chrome. Others could recognize the
  // video without it as streaming case (for example, Ubuntu Video). According
  // to spec 14496-12 C.8 'Construction of fragmented movies', it is optional
  // but it may be a good idea to implement it.
  nsresult GenerateMfra() { return NS_OK; }

  uint32_t Write(uint8_t* aBuf, uint32_t aSize);

  uint32_t Write(uint8_t aData);

  template <typename T>
  uint32_t Write(T aData) {
    MOZ_ASSERT(!mBitCount);

    aData = NativeEndian::swapToNetworkOrder(aData);
    Write((uint8_t*)&aData, sizeof(T));
    return sizeof(T);
  }

  template <typename T>
  uint32_t WriteArray(const T &aArray, uint32_t aSize) {
    MOZ_ASSERT(!mBitCount);

    uint32_t size = 0;
    for (uint32_t i = 0; i < aSize; i++) {
      size += Write(aArray[i]);
    }
    return size;
  }

  uint32_t WriteFourCC(const char* aType);

  // Bit writing. Note: it needs to be byte-boundary before using
  // others non-bit writing function.
  uint32_t WriteBits(uint64_t aBits, size_t aNumBits);

  // This is called by GetContainerData and swap the buffer to aOutBuf.
  nsresult GetBuf(nsTArray<uint8_t>& aOutBuf);

  // This function is from Android stagefright.
  // MP4 file uses time counting seconds since midnight, Jan. 1, 1904
  // while time function returns Unix epoch values which starts
  // at 1970-01-01. Lets add the number of seconds between them
  uint32_t GetTime();

  // current fragment number
  uint32_t GetCurFragmentNumber() { return mFragNum; }

  uint32_t GetFragmentDuration() { return mFragDuration; }
  nsresult SetFragmentDuration(uint32_t aDuration) {
    mFragDuration = aDuration;
    return NS_OK;
  }

  nsresult SetFragment(Fragmentation* aFragment);
  Fragmentation* GetFragment(uint32_t aType);

  nsresult SetMetadata(TrackMetadataBase* aTrackMeta);
  nsresult GetAudioMetadata(AACTrackMetadata** aAudMeta);
  nsresult GetVideoMetadata(AVCTrackMetadata** aVidMeta);

  // Track ID is the Metadata index in mMetaArray.
  uint32_t GetTrackID(uint32_t aTrackType);
  uint32_t GetNextTrackID();

  bool HasAudioTrack();
  bool HasVideoTrack();

private:
  uint32_t GetBufPos() { return mOutBuffer.Length(); }
  nsresult FlushBuf();

private:
  Fragmentation* mAudioFragmentation;
  Fragmentation* mVideoFragmentation;

  // Generated fragmentation number
  uint32_t mFragNum;
  // Tragment duration (base on seconds)
  uint32_t mFragDuration;

  // The (index + 1) will be the track ID.
  nsTArray<nsRefPtr<TrackMetadataBase> > mMetaArray;

private:
  // TODO:
  // ContainerWriter accepts a array of uint8_t array so it is possbile to
  // create a serial of small box header + swap the raw data pointer from
  // WriteEncodedTrack to another array without any memory copy.
  nsTArray<uint8_t> mOutBuffer;

  // Last written position of current box, it is for box checking purpose.
  uint32_t mLastWrittenBoxPos;

  // Accumulate size of output fragmentations.
  uint64_t mOutputSize;

  // Bit writing operation. Note: the mBitCount should be 0 before any
  // byte-boundary writting method be called (WriteInt8(), WriteInt16...etc);
  // otherwise, there will be assertion on these functions.
  uint8_t mBitCount;
  uint8_t mBit;
};

}
#endif
